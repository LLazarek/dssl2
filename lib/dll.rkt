#lang dssl2

# Given an element contract, returns a doubly-linked list factory. The
# objects generated by the factory are circular doubly-linked lists that
# support adding and removing elements from both ends.
def MakeDll(X: contract?):
    # A MaybeC(X) is one of:
    # - X
    # - False
    def MaybeC(X): OrC(X, False)

    # A Node? is Node(Node?, X, Node?), except for the sentinel node,
    # which is Node(Node?, False, Node?)
    defstruct Node(
       prev: MaybeC(Node?), # Only includes False for initialization
       data: MaybeC(X),     # Only includes False for sentinel
       next: MaybeC(Node?)) # Only includes False for initialization

    defstruct Dll (
        ElementC,               # contract?
        empty?,                 # -> bool?
        size,                   # -> int?
        front,                  # -> MaybeC(X)
        back,                   # -> MaybeC(X)
        push_front,             # X -> VoidC
        push_back,              # X -> VoidC
        pop_front,              # -> MaybeC(X)
        pop_back,               # -> MaybeC(X)
        detach_front,           # -> Dll?
        detach_back,            # -> Dll?
        splice,                 # Dll? -> VoidC
        foldl,                  # [Y] FunC(Y, X, Y), Y -> Y
        foldr,                  # [Y] FunC(X, Y, Y), Y -> Y
        each_with_index,        # FunC(int?, X, VoidC) -> VoidC
        to_vector,              # -> vec?
        get_sentinel_,          ### internal
        set_sentinel_and_size_, ### internal
    )

    # Factory method used internally for creating Dll? objects. All the
    # state and function definitions actually live here, and the main
    # public factory calls this as a helper.
    def from_sentinel_and_size(sentinel_: MaybeC(Node?), size_: int?) -> Dll?:
        if sentinel_ === False:
            sentinel_ = Node(False, False, False)
            sentinel_.prev = sentinel_
            sentinel_.next = sentinel_

        # Is this list empty?
        def empty?() -> bool?:
            sentinel_.next === sentinel_

        # Returns the number of elements in this list.
        def size() -> int?:
            size_

        # (internal)
        def get_sentinel_() -> Node?: sentinel_

        # (internal)
        def set_sentinel_and_size_(sentinel: Node?, size: int?) -> VoidC:
            sentinel_ = sentinel
            size_ = size

        # Swaps the elements of this list with another in constant time.
        def swap(other: Dll?) -> VoidC:
            let sentinel = other.get_sentinel_()
            let size = other.size()
            other.set_sentinel_and_size_(sentinel_, size_)
            set_sentinel_and_size_(sentinel, size)

        # (internal)
        # Precondition: count is number of nodes in [start, limit)
        def detach_(start: Node?, limit: Node?, count: int?) -> Dll?:
            if start === limit: return empty()
            let new_sentinel = Node(limit.prev, False, start)
            limit.prev = start.prev
            limit.prev.next = limit
            new_sentinel.next.prev = new_sentinel
            new_sentinel.prev.next = new_sentinel
            size_ = size_ - count
            from_sentinel_and_size(new_sentinel, count)

        # Removes the first `n` elements of the list into a new list.
        # (If there are fewer than `n` elements, removes all of them.)
        def detach_front(n: int?) -> Dll?:
            let count = 0
            let limit = sentinel_
            while limit.next !== sentinel_ and count < n:
                limit = limit.next
                count = count + 1
            detach_(sentinel_.next, limit.next, count)

        # Removes the last `n` elements of the list into a new list.
        # (If there are fewer than `n` elements, removes all of them.)
        def detach_back(n: int?) -> Dll?:
            let count = 0
            let start = sentinel_
            while start.prev !== sentinel_ and count < n:
                start = start.prev
                count = count + 1
            detach_(start, sentinel_, count)

        # Moves the elements from another list to the end of this list
        # in constant time. The other list is left empty.
        def splice(other: Dll?) -> VoidC:
            let other_sentinel = other.get_sentinel_()
            sentinel_.prev.next = other_sentinel.next
            other_sentinel.next.prev = sentinel_.prev
            sentinel_.prev = other_sentinel.prev
            sentinel_.prev.next = sentinel_
            size_ = size_ + other.size()
            other_sentinel.next = other_sentinel
            other.sentinel.prev = other_sentinel
            other.set_sentinel_and_size_(other_sentinel, 0)

        # Adds an element to the front of this list.
        def push_front(value: X) -> VoidC:
            let new_node = Node(sentinel_, value, sentinel_.next)
            new_node.next.prev = new_node
            new_node.prev.next = new_node
            size_ = size_ + 1

        # Adds an element to the back of this list.
        def push_back(value: X) -> VoidC:
            let new_node = Node(sentinel_.prev, value, sentinel_)
            new_node.next.prev = new_node
            new_node.prev.next = new_node
            size_ = size_ + 1

        # Removes and returns the first element of this list; if this
        # list is empty, returns False instead.
        def pop_front() -> MaybeC(X):
            if sentinel_.next === sentinel_: return False
            let result = sentinel_.next.data
            sentinel_.next = sentinel_.next.next
            sentinel_.next.prev = sentinel_
            size_ = size_ - 1
            result

        # Removes and returns the last element of this list; if this
        # list is empty, returns False instead.
        def pop_back() -> MaybeC(X):
            if sentinel_.prev === sentinel_: return False
            let result = sentinel_.prev.data
            sentinel_.prev = sentinel_.prev.prev
            sentinel_.prev.next = sentinel_
            size_ = size_ - 1
            result

        # Returns the first element of the list, or False if empty.
        def front() -> MaybeC(X):
            if sentinel_.next === sentinel_: False
            else: sentinel_.next.data

        # Returns the last element of the list, or False if empty.
        def back() -> MaybeC(X):
            if sentinel_.prev === sentinel_: False
            else: sentinel_.prev.data

        # Processes the list elements in order, accumulating a result.
        def foldl[Y](f: FunC(Y, X, Y), z: Y) -> Y:
            let current = sentinel_.next
            while current !== sentinel_:
                z = f(z, current.data)
                current = current.next
            return z

        # Processes the list elements in reverse order, accumulating a result.
        def foldr[Y](f: FunC(X, Y, Y), z: Y) -> Y:
            let current = sentinel_.prev
            while current !== sentinel_:
                z = f(current.data, z)
                current = current.prev
            return z

        # Applies the given function to each element along with its
        # position in the list.
        def each_with_index(f: FunC(int?, X, VoidC)) -> VoidC:
            foldl(lambda i, x: f(i, x); i + 1, 0)
            pass

        # Returns the elements of the list in a new vector.
        # : Self -> VectorOf<X>
        def to_vector() -> vec?:
            let v = [False; size()]
            each_with_index(lambda i, x: v[i] = x)
            v

        Dll {
            ElementC: X,
            empty?,
            size,
            front,
            back,
            push_front,
            push_back,
            pop_front,
            pop_back,
            detach_front,
            detach_back,
            splice,
            foldl,
            foldr,
            each_with_index,
            to_vector,
            get_sentinel_,
            set_sentinel_and_size_,
        }

    # Factory method for creating a new, empty doubly-linked list.
    def empty() -> Dll?:
        from_sentinel_and_size(False, 0)

    object DllFactory {
        Dll?,                   # predicate
        empty,                  # -> Dll?
    }
