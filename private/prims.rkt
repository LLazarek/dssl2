#lang racket/base

(require (only-in racket/contract/base contract-out))
(require "equal.rkt")

(provide ; values
         ; * type predicates
         num?
         int?
         nat?
         float?
         str?
         bool?
         proc?
         vec?
         contract?
         ; * contracts
         any/c ; generated by parser
         AnyC
         VoidC
         (contract-out
           [OrC (-> contract? contract? ... contract?)]
           [AndC (-> contract? contract? ... contract?)]
           [FunC (-> contract? contract? ... contract?)]
           [NewForallC (-> str? contract?)]
           [NewExistsC (-> str? contract?)]
           [IntInC (-> (OrC int? #f) (OrC int? #f) contract?)]
           [apply_contract (case-> (-> contract? AnyC AnyC)
                                   (-> contract? AnyC str? AnyC)
                                   (-> contract? AnyC str? str? AnyC))]
           [make_contract (-> str?
                              (OrC #f (-> AnyC AnyC))
                              (OrC #f (-> (-> str? VoidC) AnyC AnyC))
                              contract?)])
         ; * numeric operations
         (contract-out
           [abs (-> num? num?)]
           [floor (-> num? int?)]
           [ceiling (-> num? int?)]
           [int (-> (OrC num? str? bool?) int?)]
           [float (-> (OrC num? str? bool?) float?)]
           [max (-> num? num? ... num?)]
           [min (-> num? num? ... num?)]
           [quotient (-> int? int? int?)]
           [random (case->
                     (-> float?)
                     (-> (IntInC 1 RAND_MAX) nat?)
                     (-> int? int? int?))]
           [random_bits (-> nat? nat?)]
           [RAND_MAX nat?]
           [remainder (-> int? int? int?)]
           [sqrt (-> num? num?)])
         ; ** predicates
         (contract-out
           [zero? (-> num? bool?)]
           [positive? (-> num? bool?)]
           [negative? (-> num? bool?)]
           [even? (-> int? bool?)]
           [odd? (-> int? bool?)]
           [nan? (-> num? bool?)])
         ; * string operations
         (contract-out
           [explode (-> str? vec?)]
           [format (-> str? AnyC ... str?)]
           [str (-> AnyC str?)]
           [strlen (-> str? nat?)])
         raw-explode ; helper for language.rkt, should be removed
         ; * primitive classes
         ; ** vector
         vec vec? raw-vec->vec vec->raw-vec
         ; ** character
         char char? raw-char->char char->raw-char
         ; ** string
         String String? raw-str->str
         ; * I/O operations
         (contract-out
           [print (-> str? AnyC ... VoidC)]
           [println (-> str? AnyC ... VoidC)]
           [sleep (-> num? VoidC)])
         ; * other functions
         dir
         identity)

(require "errors.rkt"
         "object.rkt"
         (only-in racket/list
                  first
                  rest)
         (only-in racket/math
                  nan?)
         (only-in racket/contract
                  ->
                  and/c
                  any/c
                  case->
                  contract?
                  contract-out
                  contract-name
                  dynamic->*
                  flat-named-contract
                  integer-in
                  make-contract
                  new-∀/c
                  new-∃/c
                  or/c
                  raise-blame-error
                  rename-contract)
         (only-in racket/format
                  ~a)
         (only-in racket/function
                  identity)
         (prefix-in r: racket/base)
         (prefix-in r: racket/contract/base))

(define (num? x) (number? x))

(define (int? x) (exact-integer? x))

(define (nat? x) (and (int? x) (not (negative? x))))

(define (float? x) (flonum? x))

(define (str? x) (string? x))

(define (bool? x) (boolean? x))

(define (proc? x) (procedure? x))

(define AnyC (flat-named-contract 'AnyC any/c))

(define VoidC (flat-named-contract 'VoidC void?))

(define (format-fun f x xs)
  (define port (open-output-string))
  (fprintf port "~a(~e" f x)
  (for ([xi (in-list xs)])
    (fprintf port ", ~e" xi))
  (fprintf port ")")
  (get-output-string port))

(define (OrC c . cs)
  (rename-contract
    (apply or/c c cs)
    (format-fun 'OrC c cs)))

(define (AndC c . cs)
  (rename-contract
    (apply and/c c cs)
    (format-fun 'AndC c cs)))

(define (FunC c . cs)
  (define all (cons c cs))
  (define rev-all (reverse all))
  (define args (reverse (rest rev-all)))
  (define res (first rev-all))
  (rename-contract
    (dynamic->* #:mandatory-domain-contracts args
                #:range-contracts (list res))
    (format-fun 'FunC c cs)))

(define (NewForallC name)
  (new-∀/c (string->symbol name)))

(define (NewExistsC name)
  (new-∃/c (string->symbol name)))

(define (IntInC low high)
  (rename-contract
    (integer-in low high)
    (format-fun 'IntInC low (list high))))

(define apply_contract
  (case-lambda
    [(contract value pos neg)
     (r:contract contract value pos neg)]
    [(contract value pos)
     (apply_contract contract value pos "the context")]
    [(contract value)
     (apply_contract contract value "the contracted value")]))

(define (make_contract name first-order? projection)
  (make-contract #:name name
                 #:first-order first-order?
                 #:late-neg-projection
                 (λ (blame)
                    (λ (value party)
                       (projection
                         (λ (message)
                            (raise-blame-error blame
                                               #:missing-party party
                                               value
                                               message))
                         value)))))

(define (print fmt . values)
  (cond
    [(string? fmt) (display (apply format fmt values))]
    [else          (for-each display (cons fmt values))]))

(define (println fmt . values)
  (apply print fmt values)
  (newline))

(define (explode s)
  (raw-vec->vec (raw-explode s)))

(define (raw-explode s)
  (list->vector
    (r:map raw-char->char (string->list s))))

(define (str value)
  (cond
    [(string? value) value]
    [else            (format "~e" value)]))

(define (strlen str)
  (string-length str))

(define (floor n)
  (inexact->exact (r:floor n)))

(define (ceiling n)
  (inexact->exact (r:ceiling n)))

(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(string? x)
     (define n (string->number x))
     (cond
       [(int? n)  n]
       [(real? n) (inexact->exact (truncate n))]
       [else (runtime-error "int: could not convert to integer: ~s" x)])]
    [(eq? #t x)  1]
    [(eq? #f x)  0]
    [else (type-error 'int x "number, string, or Boolean")]))

(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(string? x)
     (define n (string->number x))
     (cond
       [(flonum? n) n]
       [(real? n)   (exact->inexact n)]
       [else (runtime-error "float: could not convert to float: ~s" x)])]
    [(eq? #t x)  1.0]
    [(eq? #f x)  0.0]
    [else (type-error 'int x "number, string, or Boolean")]))

; This is the largest argument that `random` can take.
(define RAND_MAX 4294967087)

(define random
  (case-lambda
    [() (r:random)]
    [(limit) (r:random limit)]
    [(low high) (r:random low high)]))

(define (random_bits n)
  (cond
    [(zero? n)      0]
    [else           (+ (* 2 (random_bits (sub1 n)))
                       (random 2))]))

(define (sleep sec)
  (r:sleep sec))

(define (sqrt x)
  (cond
    [(< x 0) (error "sqrt: cannot handle a negative")]
    [else    (r:sqrt x)]))

(define (dir obj)
  (cond
    [(object-base? obj) (raw-vec->vec (get-method-vector obj))]
    [else               (type-error 'dir obj "an object")]))

(define-primitive-class
  char
  (raw-char->char repr)
  ([__eq__        (FunC char? AnyC)
                  (λ (c) (char=? repr (char->raw-char c)))]
   [__print__     (FunC (FunC str? VoidC) (FunC AnyC VoidC) AnyC)
                  (λ (display visit)
                     (display (format "char(~a)" (char->integer repr))))]
   [__get_raw__   AnyC
                  (λ () repr)]
   [to_int        AnyC
                  (λ () (char->integer repr))]))

(define ((char/internal who) val)
  (cond
    [(char? val) val]
    [(integer? val) (raw-char->char (integer->char val))]
    [(and (string? val) (= 1 (string-length val)))
     (raw-char->char (string-ref val 0))]
    [else
      (type-error who val "int code point or singleton string")]))

(define char (char/internal 'char))

(define (char->raw-char c)
  (and (char? c) (get-raw c)))

(define-primitive-class
  String
  (raw-str->str repr)
  ([__index_ref__ (FunC nat? AnyC)
                  (λ (i) (raw-char->char (string-ref repr i)))]))

(define String
  (case-lambda
    [() (raw-str->str "")]
    [(val)
     (cond
       [(String? val) val]
       [else          (raw-str->str (format "~e" val))])]
    [(len c)
     (raw-str->str
       (make-string len (char->raw-char ((char/internal 'str) c))))]))

(define-primitive-class
  vec
  (raw-vec->vec repr)
  ([__index_ref__ (FunC nat? AnyC)
                  (λ (n) (vector-ref repr n))]
   [__index_set__ (FunC nat? AnyC AnyC)
                  (λ (n v) (vector-set! repr n v))]
   [__eq__        (FunC vec? AnyC)
                  (λ (other)
                     (define o-len (get-method-value other 'len))
                     (define o-ref (get-method-value other '__index_ref__))
                     (and (eq? (len) (o-len))
                          (for/and ([i (len)])
                            (dssl-equal? (__index_ref__ i) (o-ref i)))))]
   [__print__     (FunC (FunC str? VoidC) (FunC AnyC VoidC) AnyC)
                  (λ (display visit)
                     (define first #t)
                     (display "[")
                     (for ([element (in-vector repr)])
                        (if first
                          (set! first #f)
                          (display ", "))
                        (visit element))
                     (display "]"))]
   [__get_raw__   (FunC AnyC)
                  (λ () repr)]
   [len           AnyC
                  (λ () (vector-length repr))]
   [implode       AnyC
                  (λ ()
                     (define (convert c)
                       (cond
                         [(char->raw-char c) => identity]
                         [(integer? c)          (integer->char c)]
                         [else (type-error
                                 'vec.implode c "char or int code point")]))
                     (list->string
                       (r:map convert (vector->list repr))))]
   [map           (FunC (FunC AnyC AnyC) AnyC)
                  (λ (f)
                     (raw-vec->vec
                       (build-vector
                         (vector-length repr)
                         (λ (i) (f (vector-ref repr i))))))]
   [filter        (FunC (FunC AnyC AnyC) AnyC)
                  (λ (pred)
                     (raw-vec->vec
                       (list->vector
                         (r:filter pred (vector->list repr)))))]))

(define vec
  (case-lambda
    [() (raw-vec->vec (vector))]
    [(size) (raw-vec->vec (make-vector size #false))]
    [(size init) (raw-vec->vec (build-vector size init))]))

(define (get-raw v)
  (cond
    [(get-method-value v '__get_raw__)
     =>
     (λ (get-raw) (get-raw))]
    [else #f]))

(define (vec->raw-vec v)
  (and (vec? v) (get-raw v)))
