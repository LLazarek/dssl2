#lang racket/base

(require (only-in racket/contract/base contract-out))
(require "equal.rkt")

(provide ; values
         ; * type predicates
         num?
         int?
         nat?
         float?
         bool?
         proc?
         vec?
         contract?
         ensure-contract/fn
         ; * contracts
         any/c ; generated by parser
         AnyC
         VoidC
         (contract-out
           [OrC (-> contract? contract? ... contract?)]
           [AndC (-> contract? contract? ... contract?)]
           [FunC (-> contract? contract? ... contract?)]
           [NewForallC (-> str? contract?)]
           [NewExistsC (-> str? contract?)]
           [IntInC (-> (OrC int? #f) (OrC int? #f) contract?)]
           [apply_contract (case-> (-> contract? AnyC AnyC)
                                   (-> contract? AnyC str? AnyC)
                                   (-> contract? AnyC str? str? AnyC))]
           [make_contract (-> str?
                              (OrC #f (-> AnyC AnyC))
                              (OrC #f (-> (-> str? VoidC) AnyC AnyC))
                              contract?)])
         ; * numeric operations
         (contract-out
           [abs (-> num? num?)]
           [floor (-> num? int?)]
           [ceiling (-> num? int?)]
           [int (-> (OrC num? str? bool?) int?)]
           [float (-> (OrC num? str? bool?) float?)]
           [max (-> num? num? ... num?)]
           [min (-> num? num? ... num?)]
           [quotient (-> int? int? int?)]
           [random (case->
                     (-> float?)
                     (-> (IntInC 1 RAND_MAX) nat?)
                     (-> int? int? int?))]
           [random_bits (-> nat? nat?)]
           [RAND_MAX nat?]
           [remainder (-> int? int? int?)]
           [sqrt (-> num? num?)])
         ; ** predicates
         (contract-out
           [zero? (-> num? bool?)]
           [positive? (-> num? bool?)]
           [negative? (-> num? bool?)]
           [even? (-> int? bool?)]
           [odd? (-> int? bool?)]
           [nan? (-> num? bool?)])
         ; * primitive classes
         ; ** vector
         vec vec? raw-vec->vec vec->raw-vec
         ; ** character
         char char? raw-char->char char->raw-char
         ; ** string
         str str? raw-str->str str->raw-str ensure-string
         raw-explode str->contract
         ; * I/O operations
         (contract-out
           [print (-> str? AnyC ... VoidC)]
           [println (-> str? AnyC ... VoidC)]
           [sleep (-> num? VoidC)])
         ; * other functions
         dir
         identity)

(require "errors.rkt"
         "object.rkt"
         (only-in racket/list
                  first
                  rest)
         (only-in racket/math
                  nan?)
         (only-in racket/contract
                  ->
                  and/c
                  any/c
                  case->
                  contract-out
                  contract-name
                  dynamic->*
                  flat-named-contract
                  integer-in
                  make-contract
                  new-∀/c
                  new-∃/c
                  or/c
                  raise-blame-error
                  rename-contract)
         (only-in racket/function
                  identity)
         (prefix-in r: racket/base)
         (prefix-in r: racket/contract/base))

(define (num? x) (number? x))

(define (int? x) (exact-integer? x))

(define (nat? x) (and (int? x) (not (negative? x))))

(define (float? x) (flonum? x))

(define (bool? x) (boolean? x))

(define (proc? x) (procedure? x))

(define (contract? x)
  (or (and (r:contract? x)
           (not (string? x)))
      (str? x)))

(define AnyC (flat-named-contract 'AnyC any/c))

(define VoidC (flat-named-contract 'VoidC void?))

(define (format-fun f x xs)
  (define port (open-output-string))
  (fprintf port "~a(~e" f x)
  (for ([xi (in-list xs)])
    (fprintf port ", ~e" xi))
  (fprintf port ")")
  (get-output-string port))

(define (ensure-contract/fn srclocs who contract)
  (if (contract? contract)
    (if (str? contract)
      (str->contract contract)
      contract)
    (runtime-error #:srclocs srclocs
                   "~a: expected a contract\n got: ~e"
                   who contract)))

(define (OrC c . cs)
  (rename-contract
    (apply or/c
           (map (λ (c) (ensure-contract/fn '() 'OrC c))
                (cons c cs)))
    (format-fun 'OrC c cs)))

(define (AndC c . cs)
  (rename-contract
    (apply and/c c cs)
    (format-fun 'AndC c cs)))

(define (FunC c . cs)
  (define all (cons c cs))
  (define rev-all (reverse all))
  (define args
    (map (λ (c) (ensure-contract/fn '() 'FunC c))
         (reverse (rest rev-all))))
  (define res (ensure-contract/fn '() 'FunC (first rev-all)))
  (rename-contract
    (dynamic->* #:mandatory-domain-contracts args
                #:range-contracts (list res))
    (format-fun 'FunC c cs)))

(define (NewForallC name)
  (new-∀/c (string->symbol (ensure-string 'NewForallC name))))

(define (NewExistsC name)
  (new-∃/c (string->symbol (ensure-string 'NewExistsC name))))

(define (IntInC low high)
  (rename-contract
    (integer-in low high)
    (format-fun 'IntInC low (list high))))

(define apply_contract
  (case-lambda
    [(contract value pos neg)
     (r:contract contract value pos neg)]
    [(contract value pos)
     (apply_contract contract value
                     (ensure-string 'apply_contract pos)
                     (raw-str->str "the context"))]
    [(contract value)
     (apply_contract contract value
                     (raw-str->str "the contracted value"))]))

(define (make_contract name first-order? projection)
  (make-contract #:name (ensure-string 'make_contract name)
                 #:first-order first-order?
                 #:late-neg-projection
                 (λ (blame)
                    (λ (value party)
                       (projection
                         (λ (message)
                            (raise-blame-error
                              blame
                              #:missing-party party
                              value
                              (ensure-string 'raise-blame-error message)))
                         value)))))

(define (print fmt . values)
  (apply printf (str->raw-str fmt) values))

(define (println fmt . values)
  (apply print fmt values)
  (newline))

(define (raw-explode s)
  (list->vector
    (r:map raw-char->char (string->list s))))

(define (floor n)
  (inexact->exact (r:floor n)))

(define (ceiling n)
  (inexact->exact (r:ceiling n)))

(define (int x)
  (cond
    [(number? x) (inexact->exact (truncate x))]
    [(str? x)
     (define n (string->number (str->raw-str x)))
     (cond
       [(int? n)  n]
       [(real? n) (inexact->exact (truncate n))]
       [else (runtime-error "int: could not convsrt to integer: ~e" x)])]
    [(eq? #t x)  1]
    [(eq? #f x)  0]
    [else (type-error 'int x "number, string, or Boolean")]))

(define (float x)
  (cond
    [(number? x) (exact->inexact x)]
    [(str? x)
     (define n (string->number (str->raw-str x)))
     (cond
       [(flonum? n) n]
       [(real? n)   (exact->inexact n)]
       [else (runtime-error "float: could not convert to float: ~e" x)])]
    [(eq? #t x)  1.0]
    [(eq? #f x)  0.0]
    [else (type-error 'int x "number, string, or Boolean")]))

; This is the largest argument that `random` can take.
(define RAND_MAX 4294967087)

(define random
  (case-lambda
    [() (r:random)]
    [(limit) (r:random limit)]
    [(low high) (r:random low high)]))

(define (random_bits n)
  (cond
    [(zero? n)      0]
    [else           (+ (* 2 (random_bits (sub1 n)))
                       (random 2))]))

(define (sleep sec)
  (r:sleep sec))

(define (sqrt x)
  (cond
    [(< x 0) (error "sqrt: cannot handle a negative")]
    [else    (r:sqrt x)]))

(define (dir obj)
  (cond
    [(object-base? obj) (raw-vec->vec (get-method-vector obj))]
    [else               (type-error 'dir obj "an object")]))

(define-primitive-class
  char
  (raw-char->char repr)
  ([__eq__        (FunC char? AnyC)
                  (λ (c) (char=? repr (char->raw-char c)))]
   [__print__     AnyC
                  (λ (print)
                     (print "char(~a)" (char->integer repr)))]
   [__get_raw__   AnyC
                  (λ () repr)]
   [to_int        AnyC
                  (λ () (char->integer repr))]))

(define (char/internal who val)
  (cond
    [(char? val) val]
    [(integer? val) (raw-char->char (integer->char val))]
    [(str->raw-str val)
     =>
     (λ (raw-str)
        (if (= 1 (string-length raw-str))
          (raw-char->char (string-ref raw-str 0))
          (type-error who val "int code point or singleton string")))]
    [else
      (type-error who val "int code point or singleton string")]))

(define char
  (case-lambda
    [() (char 0)]
    [(val) (char/internal 'char val)]))

(define (char->raw-char c)
  (and (char? c) (get-raw c)))

(define-primitive-class
  str
  (raw-str->str repr)
  ([__index_ref__ (FunC nat? AnyC)
                  (λ (i) (raw-char->char (string-ref repr i)))]
   [__eq__        (FunC str? AnyC)
                  (λ (other) (string=? repr (str->raw-str other)))]
   [__get_raw__   AnyC
                  (λ () repr)]
   [len           AnyC
                  (λ () (string-length repr))]
   [explode       AnyC
                  (λ () (raw-vec->vec (raw-explode repr)))]
   [format        AnyC
                  (λ args (raw-str->str (apply r:format repr args)))]))

(define str
  (case-lambda
    [() (raw-str->str "")]
    [(val)
     (cond
       [(str? val) val]
       [else          (raw-str->str (format "~e" val))])]
    [(len c)
     (raw-str->str
       (make-string len (char->raw-char (char/internal 'str c))))]))

(define (str->raw-str s)
  (and (str? s) (get-raw s)))

(define (ensure-string who value)
  (cond
    [(string? value) value]
    [(and (object-base? value) (get-raw value))
     =>
     (λ (raw) (ensure-string who raw))]
    [else
      (type-error who value "format string")]))

(define (str->contract str)
  (rename-contract
    (λ (value)
       (and (str? value)
            ((get-method-value str '__eq__) value)))
    ((get-method-value str '__get_raw__))))

(define-primitive-class
  vec
  (raw-vec->vec repr)
  ([__index_ref__ (FunC nat? AnyC)
                  (λ (n) (vector-ref repr n))]
   [__index_set__ (FunC nat? AnyC AnyC)
                  (λ (n v) (vector-set! repr n v))]
   [__eq__        (FunC vec? AnyC)
                  (λ (other)
                     (define o-len (get-method-value other 'len))
                     (define o-ref (get-method-value other '__index_ref__))
                     (and (eq? (len) (o-len))
                          (for/and ([i (len)])
                            (dssl-equal? (__index_ref__ i) (o-ref i)))))]
   [__print__     AnyC
                  (λ (print)
                     (define first #t)
                     (print (raw-str->str "["))
                     (for ([element (in-vector repr)])
                        (if first
                          (set! first #f)
                          (print (raw-str->str ", ")))
                        (print (raw-str->str "~e") element))
                     (print (raw-str->str "]")))]
   [__get_raw__   (FunC AnyC)
                  (λ () repr)]
   [len           AnyC
                  (λ () (vector-length repr))]
   [implode       AnyC
                  (λ ()
                     (define (convert c)
                       (cond
                         [(char->raw-char c) => identity]
                         [(integer? c)          (integer->char c)]
                         [else (type-error
                                 'vec.implode c "char or int code point")]))
                     (raw-str->str
                       (list->string
                         (r:map convert (vector->list repr)))))]
   [map           (FunC (FunC AnyC AnyC) AnyC)
                  (λ (f)
                     (raw-vec->vec
                       (build-vector
                         (vector-length repr)
                         (λ (i) (f (vector-ref repr i))))))]
   [filter        (FunC (FunC AnyC AnyC) AnyC)
                  (λ (pred)
                     (raw-vec->vec
                       (list->vector
                         (r:filter pred (vector->list repr)))))]))

(define vec
  (case-lambda
    [() (raw-vec->vec (vector))]
    [(size) (raw-vec->vec (make-vector size #false))]
    [(size init) (raw-vec->vec (build-vector size init))]))

(define (get-raw v)
  (cond
    [(get-method-value v '__get_raw__)
     =>
     (λ (get-raw) (get-raw))]
    [else #f]))

(define (vec->raw-vec v)
  (and (vec? v) (get-raw v)))
