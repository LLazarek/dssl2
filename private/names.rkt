#lang racket/base

(provide public-method-name?
         class-qualify/sym
         (for-syntax class-qualify)
         struct-predicate-name
         struct-special-name
         struct-special-name/located
         interface-contract-name
         struct-getter-name
         struct-setter-name)

(require syntax/parse/define
         (only-in racket/string string-prefix?)
         (only-in racket/syntax format-id))
(require (for-syntax racket/base
                     (only-in racket/syntax format-id)))

(define (public-method-name? stx)
  (define name (symbol->string (syntax-e stx)))
  (or (not (string-prefix? name "_"))
      (string-prefix? name "__")))

(define (class-qualify/sym qualifier property)
  (format "«~a».~a" qualifier property))

(define-for-syntax (class-qualify qualifier property)
    (format-id property "«~a».~a" qualifier property
               #:source property
               #:props property))

(define (struct-predicate-name name)
  (format-id name "~a?" name
             #:source name
             #:props name))

; Names like this are generated by the parser.
(define (struct-special-name name)
  (format-id name "~a{}" name))

; Here's the function the parser uses.
(define (struct-special-name/located name)
  (format-id #f "~a{}" name #:source name))

(define (interface-contract-name name)
  (format-id name "~a!" name #:source name #:props name))

(define-syntax (struct-getter-name stx)
  (syntax-parse stx
    [(_ name:id field:id)
     (format-id #'name "~a-~a" #'name #'field)]))

(define-syntax (struct-setter-name stx)
  (syntax-parse stx
    [(_ name:id field:id)
     (format-id #'name "set-~a-~a!" #'name #'field)]))


